---
params:
  eval_slow: true
title: ""
author: ""
date: ""
output:
  html_document:
    toc: true
---

```{r setup, include = FALSE}
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
knitr::opts_chunk$set(
  echo = TRUE,
  # cache = TRUE,
  cache = FALSE,
  include = TRUE,
  fig.align = "center",
  results = "asis",
  fig.width = 6,
  fig.height = 6,
  # out.width = 6,
  # out.height = 6,
  warning = FALSE,
  message = FALSE
)
options(scipen = 1, digits = 2)
```

```{r config, include = FALSE}
config <-
  list(
    export_data = TRUE,
    dir_data = "data",
    export_viz = TRUE,
    dir_viz = "figs"
  )
```

## Introduction

```{r packages}
library("tidyverse")
library("mlbench")
data("PimaIndiansDiabetes")
```

```{r data_show}
PimaIndiansDiabetes
```


```{r fmla_diabetes}
fmla_diabetes <- formula(diabetes ~ .)
```

### Traditional {caret} Usage

...

### purrr + mutate + unnest Combo Approach #1

...

Excuse the verbosity (with the `_tree` suffix) here...

Because I like being explicity with namespaces, I modified
the following function from a Stack Overflow response.
This is needed if wanting to specify the namespace of a function (i.e. with `pkg::function()` notation)
when using `do.call()`.

```{r do_call_with}
do_call_with <-
  function(what, args, ...) {
    if (is.character(what)) {
      fn <- strsplit(what, "::")[[1]]
      what <- if (length(fn) == 1) {
        get(fn[[1]], envir = parent.frame(), mode = "function")
      }
      else {
        get(fn[[2]], envir = asNamespace(fn[[1]]), mode = "function")
      }
    }
    do.call(what, as.list(args), ...)
  }
```

```{r grid_preproc}
grid_preproc <-
  tibble(
    preprocess_desc = c("Scaled", "Unscaled"),
    preproc = c("scale", "none")
  )
```

```{r grid_methods_tree}
grid_methods_tree <-
  tribble(
    ~method_desc,
    "{rpart} CART",
    "{randomForest} Random Forest",
    "{ranger} Random Forest"
  ) %>% 
  crossing(
    grid_preproc
  ) %>% 
  unite(method_desc, method_desc, preprocess_desc, sep = ", ") %>% 
  mutate(idx_method = row_number()) %>% 
  select(idx_method, everything())
grid_methods_tree
```

```{r setup_caret_tree_funcs, eval = params$eval_slow}
setup_caret_tree_base <-
  function() {
    list(
      form = fmla_diabetes,
      data = PimaIndiansDiabetes,
      trControl = caret::trainControl(method = "cv", number = 5),
      metric = "Accuracy"
    )
  }

setup_caret_rpart <-
  function() {
    list(method = "rpart",
         minsplit = 5,
         tuneGrid = data.frame(cp = 10 ^ seq(-2, 1, by = 1)))
  }

setup_caret_rf <-
  function() {
   list(method = "rf", tuneGrid = data.frame(mtry = c(3, 5, 7)))
  }

setup_caret_ranger <-
  function() {
    list(method = "ranger",
         tuneGrid = 
           expand.grid(
             mtry = c(3, 5, 7),
             splitrule = c("gini"),
             min.node.size = 5,
             stringsAsFactors = FALSE
            )
    )
  }

fit_caret_tree_sprintf <-
  function(method = NULL, preproc = NULL) {
    do_call_with(
      caret::train,
      c(
        do.call("setup_caret_tree_base", args = list()),
        do.call(sprintf("setup_caret_%s", method), args = list()),
        preProcess = preproc
      )
    )
  }
```


```{r fits_diabetes_tree, eval = params$eval_slow}
set.seed(42)
fits_diabetes_tree <-
  tribble(
    ~fit,
    fit_caret_tree_sprintf(method = "rpart", preproc = NULL),
    fit_caret_tree_sprintf(method = "rpart", preproc = "scale"),
    fit_caret_tree_sprintf(method = "rf", preproc = NULL),
    fit_caret_tree_sprintf(method = "rf", preproc = "scale"),
    fit_caret_tree_sprintf(method = "ranger", preproc = NULL),
    fit_caret_tree_sprintf(method = "ranger", preproc = "scale")
  ) %>% 
  mutate(idx_method = row_number()) %>% 
  left_join(grid_methods_tree)
fits_diabetes_tree
```

```{r fits_diabetes_tree_export, include = FALSE, eval = params$eval_slow}
teproj::export_ext_rds(
  fits_diabetes_tree,
  export = TRUE,
  dir = "data"
)
```

```{r fits_diabetes_tree_import, include = FALSE}
fits_diabetes_tree <-
  teproj::import_ext_rds(
    fits_diabetes_tree,
    dir = "data"
  )
```


### Pros & Cons

+ Pros
    + basic `sprintf()` function that takes `"method"` as input
    + can pass `preproc` as `NULL`
+ Cons
    + matching index

## purrr + mutate + unnest combo Approach #2

```{r setup_caret_knnsvm_funcs}
setup_caret_base_tree_2 <-
  function(preproc = "scale") {
    list(
      form = fmla_diabetes,
      data = PimaIndiansDiabetes,
      preProcess = ifelse(preproc == "none", NULL, preproc),
      trControl = caret::trainControl(method = "cv", number = 5),
      metric = "Accuracy"
    )
  }

get_caret_args_tree <-
  function(method = NULL, preproc = "scale") {
    c(
      do.call("setup_caret_base_knnsvm_2", args = list(preproc = preproc)),
      do.call(sprintf("setup_caret_%s", method), args = list(preproc = preproc))
    )
  }

fit_caret_tree <-
  function(method = NULL, preproc = NULL) {
    do_call_with(
      caret::train,
      get_caret_args_tree(method = method, preproc = preproc)
    )
  }
```


```{r fits_diabetes_tree, eval = params$eval_slow}
set.seed(42)
fits_diabetes_tree_2 <-
  grid_methods_tree %>%
  # slice(-c(1:2)) %>% 
  group_by(idx_method, method_desc) %>% 
  nest() %>% 
  mutate(fit = purrr::map(data, ~fit_caret_tree(method = .x$method, preproc = .x$preproc))) %>% 
  ungroup()
fits_diabetes_tree_2
```

### Comparison of the Two Approaches


|  Category|  Approach #1|  Approach #2|
|---|---|---|
| Method-Specific Functions| Requires functions for each method| Requires function for each method
| User API| User must call `_sprintf()` function (with `"method"` specified as input)|  Facilitates "`nest()` +  `mutate()` + `unnest()`"|
| `preProcess` handling| Handled with `fit_caret_*` function| Requires an extra function (i.e. `get_caret_args_*()`)|

Perhaps the major thing to note here is that both approaches require explicit
functions for each method to be used. I think it would be cool if
we could set-up another "layer of abstraction" with a `do.call()` and/or `sprintf()`,
but I believe that this is only possible for methods with exactly the
same `tuneGrid` parameters to set.

If achieving this extra layer of abstraction were a priority, then it could
be done by not specifying `tuneGrid` at all. However, this approach
gives up control over all of the tuning parameters, although specifying `tuneLength`
might be deemed an agreeable compromise).

### Alternative Approaches for Implementing `preProcess = NULL`

As an alternative to passing `preproc` to `setup_caret_base_tree_2()` in approach #2,
we could remove that argument and modify the `get_caret_args_tree()` function in the following way.

```{r get_caret_args_alt, eval = FALSE}
# Note that preProcess = ifelse(preproc == "none", NULL, preproc) does not work here.
# Alternatively, do this.
get_caret_args_tree_alt <-
  function(method = NULL, preproc = "scale") {
    ret <-
      c(
        do.call("setup_caret_base_tree", args = list()),
        do.call(sprintf("setup_caret_%s", method), args = list())
      )
    if(preproc != "none") {
      ret <- c(ret, preProcess = preproc)
    }
    ret
  }
```

Yet another alternative would be make `preproc` a parameter for each
of the specific `setup_caret_*()` model functions. (Again, `preproc` would
no longer need to be passed to `setup_caret_base_knnsvm()`.)

```{r setup_caret_ksvm_linear_alt, eval = FALSE}
setup_caret_ksvm_linear_alt <-
  function(preproc = "scale") {
    list(
      method = "svmLinear",
      preProcess = preproc,
      tuneGrid = data.frame(C = c(0.25, 0.5, 1))
    )
  }

# ...
```

## Quantifying Model Quality

```{r unnest_caret_results}
unnest_caret_results <-
  function(fit = NULL, na.rm = TRUE) {
    fit %>%
      mutate(results = map(fit, ~pluck(.x, "results"))) %>% 
      unnest(results, .drop = TRUE)
  }
```

```{r summ_diabetes_tree}
summ_diabetes_tree <-
  fits_diabetes_tree %>%
  unnest_caret_results() %>% 
  select(-matches("SD")) %>% 
  arrange(desc(Accuracy))
summ_diabetes_tree
```

## Conclusion

Show how to do this when you don't want to scale across all methods...
Possibly show different random forest methods and/or step-wise regression methods...
Possibly split more complex stuff out to a second post.

```{r save, include = FALSE}
if(config$export_data) {
  vars_all <- ls()
  vars_keep <-
    vars_all %>% 
    str_subset("^config$||^PimaIndiansDiabetes$|^fmla_diabetes$|^do_call_with$|^unnest_caret_results$")
  vars_rm <- setdiff(vars_all, vars_keep)
  rm(list = vars_rm)
  path_save <-
    file.path(config$dir_data, "01.RData")
  save.image(file = path_save)
}
```
